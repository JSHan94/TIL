# Go 언어의 특징

- 고수준, 정적 컴파일, (초초!) 강 타입 언어 (자동 타입 변환 미지원), 가비지 컬렉터
- 클래스 : 클래스는 없지만 Struct에서 Method를 가질 수 있음
- 인터페이스 : 상속은 없지만 인터페잇스는 있음
- 익명 함수 : 함수 리터럴이라는 이름으로 제공 됨(이름이 없는 함수)
- 가비지 컬렉터 : 고성능의 가비지 컬렉터 지원
- 포인터 : C와 유사한 포인터 지원
- 제넡릭 프로그래밍 : 제너릭이란 하나의 값이 여러 다른 데이터 타입을 가지는 것인데, 강 타입인 Go에서는 지원하지 않음
- 네임스페이스 : 네임스페이스를 지원하지 않고 패키지 단위로 코드가 분리 됨

### Go Type 종류

- boolean, string, pointer, struct, function pointer, map
- array : 연속된 메모리 공간을 나타내는 자료 구조, array는 고정 길이를 가져서 바꿀 수 없음
- slice : 길이가 가변적인 array, 시작점 주소, 실제 데이터 수(len), 허용 범위(cap)을 가짐
- interface : 메서드의 집합
    - Duck typing : **어떤 새가 오리처럼 날고 울면 그 새는 오리일 것이다**. 어떤 객체의 타입은 그 객체의 변수나 메서드 집합에 따라 타입이 결정된다
- channel : 멀티스레드 환경에서 특화된 큐 형태의 자료구조. Go routine에서 특정 값을 각 루틴들에서 공유하기 위해 사용됨

### Remind

- 2의 보수의 장점 : 음수를 최상위 비트로 할 경우 생기는 +0, -0 개념을 없앨 수 있음. 또한 음수로 바꾼 값(2의 보수를 적용시킨)과 원래 값을 더하면 0이 됨
- close, free 등을 하는 이유 : 프로그램이 os에서 빌린 자원을 반납하지 않으면, 메모리 leak 등 자원이 고갈되어 문제가 발생할 수 있음
- Scan()함수 동작 원리 : 표준 입력 장치에서 데이터를 받으면 데이터는 standard input stream이라는 FIFO 형태의 메모리 공간에 임시 저장됨. Scan() 함수는 이 값을 읽어서 하나씩 처리하는데 만약 `Hello`가 스트림에 저장되어 있을 때 `H`를 읽고나서 에러가 발생할 경우 버퍼에는 `ello`가 남아있게 됨. 만약 이후 Scan() 함수가 호출 될 경우, 스트림에 남아있는 값을 읽게 됨
- 부동 소수 : 2진법의 한계상 엄밀한 소수점 표현이 불가능한데, x < target < y 와 같은 순간이 있음. x->y로 가는 오차를 줄이는 방법으로 x에서 1비트 값만 올리는 형태의 함수 (Nextafter)가 제공되기도 함
- 메모리 정렬(Memory alignment) : 32비트 컴퓨터는 4바이트, 64비트는 8바이트로 레지스터 크기가 설정되어 있어 이 값의 배수로 메모리가 정렬되어 있음그렇기 때문에 이 값에 맞게 struct 같은 데이터 타입의 초기 세팅을 설정해야 효율적으로 메모리를 활용할 수 있음(메모리 패딩을 줄일 수 있음)
- Coupling과 Cohesion : Coupling은 모듈간 상호 의존 관계로 인해 강하게 결합된 것을 의미, Cohesion은 모듈의 완성도를 말하는 것으로 기능들이 하나의 목적에 맞게 잘 모여 있는 지를 의미 함. 일반적으로 Coupling은 줄이고, Cohesion은 높이는 것을 목표로 해야 함
- 스택 메모리와 힙 메모리 : 이론상 스택 메모리 영역이 힙 영역보다는 훨씬 효율적이지만, 스택 메모리는 함수 내부에서만 사용 가능한 영역임. 그래서 함수 외부로 공개되는 메모리 공간은 힙 메모리에 할당이 됨
    - C/C++ : malloc() 함수를 호출해서 힙 메모리 공간을 할당
    - Java : 클래스 타입을 힙에, 기본 타입을 스택에 할당
    - Go : escape analysis를 통해 어느 메모리에 할당할 지를 결정
- Dangling 오류 : 코드가 이미 사라진 메모리를 가르키는 오류
- SOLID, TDD

# Go의 특이한 사용법

- 변수이름이 대문자로 시작하면 다른 패키지에 import 시 접근하는 것이 가능 함. 소문자로 시작할 경우에는 엑세스 불가능
- iota라는 열거값을 사용함. 0부터 시작되고 값이 1씩 증가함. 초기값을 어떻게 설정하냐에 따라서 이후 열거값들이 바뀌는 패턴을 결정할 수 있음
- 타입이 없는 형태로 const를 부여할 경우에는 해당 상수가 사용되는 위치에, 상수의 값이 그대로 복사 붙혀넣기가 됨. 고정된 값 자체로 쓰이는 문구인 `리터럴`임. Go에서 상수는 리터럴과 같이 취급 되며 컴파일 시 상수는 리터럴로 변환되어 처리됨. 컴파일 타임에 상수 표현식 계산에 CPU 자원이 사용되지 않음
```Go
const PI=3.14
const FloatPI float64 = 3.14
var a int = PI*100 // 오류 발생하지 않음
var b int = FloatPI*100 // 타입 오류 발생
```
- switch문에서 기본적으로 각 케이스마다 break가 적용되며, 이어서 바로 다음 케이스까지 처리하고 싶으면 `fallthrough` 라는 키워드를 사용해야 함
- 문자열을 순회하는 방법
    - 인덱스를 사용한 바이트 단위 순회 : 이 경우에는 한글은 1바이트 씩 순회를 하는데 한글 같은 문자는 3바이트 크기라 깨져서 표기될 수 있음
    - []rune 타입으로 변환 후 한 글자씩 순회
    - range 키워드를 이용하여 한 글자씩 순회
- 패키지 초기화 : 패키지를 import하면 패키지 내의 init() 함수가 자동으로 실행 되는데, 특정 패키지의 init()만을 사용하기 위해 import를 하는 경우도 있음


### 함수 고급편

- 가변인수 : `...` 키워드를 이용하여 인수의 갯수를 가변적으로 받음
- defer 지연 실행 : 함수가 종료되기 전에 실행하는 코드
- 함수 타입 변수 : CPU 내부에서 Program counter에 따라 코드에서 실행될 라인이 결정 됨. 함수의 시작 지점 역시 숫자로 표현할 수 있고 이 값을 가리키는 값이 `함수 포인터`임. 이와 같이 함수 역시 숫자로 표현될 수 있기에 변수의 값이 될 수 있으며 이는 코드 블록 `{}`을 제외한 `function signature`(함수 정의만 있는)로 표시 함
- 함수 리터럴 : 함수명을 적지 않고 함수 타입 변숫값으로 대입되는 함숫 값. 다른 언어에서는 익명 함수 또는 람다(lambda)라고 불리기도 함. 함수 리터럴 외부 변수를 내부 상태로 가져오는 것을 capture라고 하는데 이 때 value copy가 아닌 reference copy 형태로 가져오기 때문에 주의해야 함

### Go routine과 동시성 프로그래밍

- Thread
    - 기본적으로 하나의 코어에서 여러 Thread를 빠르게 스위칭 하면서 여러 작업이 동시에 처리되는 것처럼 보이게 할 수 있음. 하지만 이 방법의 경우 switching cost가 발생하게 됨.
- Go routine
    - Go의 경우 운영체제가 지원하는 OS thread를 이용하는 lightweight thread 임
    - 고루틴이 존재하면 OS thread를 하나 만들어 첫 번째 코어와 연결하여 다음과 같은 형태로 만들게 됨. `코어 - OS thread - 고루틴` 
    - 만약 코어가 2개고 고루틴이 3개일 경우에는 2개의 고루틴이 돌아가고, 나머지 하나는 대기하고 있게 됨. 만약 시스템 콜 호출 등으로 특정 고루틴이 대기 상태로 가게되면, 대기 리스트에 있던 고루틴과 교체되게 됨. 이 때 OS thread를 이용하는 다른 언어들과 달리 고루틴만 교체되기 때문에 context switching 비용이 발생하지 않음. 그렇기 때문에 마음껏 고루틴을 생성하는 것이 가능함
- 동시성 프로그래밍
    - 동일한 자원을 동시에 고루틴이 사용하게 될 경우 문제가 발생할 수 있기 때문에 `뮤텍스`를 사용하여 자원 관리를 해야할 수 있음. 이 때 원하는 뮤텍스를 확보하지 못하여 데드락이 발생할 수도 있음을 고려해야 함 
    - 고루틴에서는 `영역을 나누는 방법`, `역할을 나누는 방법`을 이용하여 자원 관리를 하는 것이 가능 함


### 채널과 컨택스트

- 채널
    - 고루틴끼리 메시지를 전달할 수 있는 메시지 큐. 아래와 같은 형태로 사용 가능
    - 채널 생성 : ```var message chan string = make(chan string)```
    - 채널에 데이터 넣기 : ```messages <- "this is a message"```
    - 채널에서 데이터 빼기 : ```var msg string = <- messages```
    - 채널의 크기는 기본적으로 크기가 0으로 셋팅 되는데 이경우 보관할 곳이 없어 데이터를 빼갈 때까지 대기하게 됨
    - 이를 해결하기 위해 채널 생성 시 데이터를 보관할 수 있는 버퍼를 추가 함
    - 여러 채널을 동시에 대기하기 위하여 ```select``` 키워드를 이용하기도 함
    - 채널을 이용하여 `생산자-소비자` 패턴을 구현하는 것 또한 가능함. 이는 채널을 이용하여 코드의 역할을 나누는 것이 가능하게 함
- 컨택스트
    - context는 context 패키지에서 제공하는 기능으로 작업을 지시할 때 작업 가능 시간, 작업 취소 등의 조건을 지시할 수 있는 `작업 명세서`

### 알아 둘 것

- interface의 타입 변환
- panic()과 recover() 함수
- Error wrapping
